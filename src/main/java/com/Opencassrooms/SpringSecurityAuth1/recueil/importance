Les attaques sur les applications Web : piratage informatique des données, l'injection de code SQL, ect
Le complexe Hotelier Mariott a été victime de l'un des piratages informatiques des données les plus importants de l'histoire avec
500 millions de clients affectés et une perte de 3 millions de dollars. Yahoo et Equifax ont été aussi victimes du piratage informatiques
des données.Il faut s'assurer de la fibialité des frameworks et les dépendances(plug-in,libraries et autres) que l'on utilise.
OWASP définit un Top 10 des attaques visant les applications web.
Différence entre Spring, Spring Boot, Spring MVC, RESTful API ou monopage.
Spring Security repose sur trois conceptes :
-Le pare-feu(firewall) : il permet de s'assurer que seules les requetes autorisées peuvent passer à travers les filtres
et atteindre les couches de l'applcation. Spring Security utilise un composant appelé "HttpFirewall" qui est chargé de vérifier
et d'empecher les requetes HTTP malveillants ou invalides.
Par exemple, il peut bloquer : des requetes contenant des caracteres interdits ou des tentatives de traversée de répertoire (../)
ou des tentatives d'injections via des URL malformées.
-Le proxy :
 1- Proxy d'autorisation : Utilisé pour entourer les objets sensibles, permettant de vérifier dynamiquement les permissions et sécuriser
    l'accès aux ressources/méthodes. Souvent on utilise "@PreAuthorize" ou @Secured.
 2-Proxy DelegatingFilterProxy : il opère dans le cycle de vie des requetes HTTP. Il permet de transporter une requete entrante vers
   la chaine de filtre concernant.
-Les chaines de filtres(filter chain) : une chaine de filtre est une serie de filtres Servlet qui intercepte chaque requete entrante
pour garantir que chaque requete passe les étapes de validation et de sécurité nécessaire avant d'atteindre le controller.
Dans Java, un servlet est un programme qui fonctionne sur une applicaion Web pour traiter des requetes HTTP entrantes.
Un filtre Servlet est un composant qui peut agir en amount sur la requete reçue par le ou les servlets concernés par le filtre en question.
On a trois dépendances :
-Spring Web : permet d'implémenter des applications(autrement dit on peut traiter des requetes HTTP et renvoyer des reponses HTTP);
-SpringSecurity : permet d'impémenter la couche de sécurité (tant l'authentification que l'authorisation);
-OAuth2 : permet d'utiliser le protocole de OAuth2 avec Spring Security
-La hiéarchie des dépendances exitent en Spring Boot, qui dit que certaines dépendances doit précéder d'autres comme exemple OAUth2 suivi de
Spring Security et suivi Spring Web.
Les deux fonctionnalités de sécurisation sont : l'authentification vérifie qui vous etes et
l'autorisation vérifie ce que vous pouvez faire. C'est deux constitue le controe d'accés.
Il existe deux formes d'authentification : l'authentification à facteur unique et l'authentification à facteurs multiples.
Les types d'authentification en Spring Security :
 -Par Session: Dans l’authentification par session, les utilisateurs se connectent d’abord grâce à leurs identifiants.
    Ils sont alors authentifiés et commencent une session. Une session représente la période entre la connexion et la déconnexion
    de l’utilisateur. Le serveur sauvegarde les informations de session de l’utilisateur, et écrit une copie de ces informations
    dans un petit fichier (un cookie), également sauvegardé dans le navigateur de l’utilisateur. Ces informations contiennent généralement les identifiants de l’utilisateur, la durée de la session et un numéro de session. Chaque fois que l’utilisateur envoie une requête via l’application web, le serveur consulte le cookie pour s’assurer que les identifiants de la session correspondent à ceux du serveur, et sont encore valides.
 -Par token
    Dans le cadre de l'authentification par token, l’utilisateur s'authentifie sur le serveur, et ce dernier écrit les informations
    de la session dans un petit fichier (un token) pour effectuer la sauvegarde uniquement sur le navigateur ou l’ordinateur de
    l’utilisateur. Un token a la même fonction qu’un cookie, mais ces deux processus présentent tout de même des différences
    significatives. Une authentification par session avec cookie sauvegarde les identifiants sur le serveur et sur le navigateur de
    l’utilisateur. Tandis que lors d’une authentification par token, un token web JSON (JWT) dispose déjà des informations nécessaires
    pour valider l’utilisateur ; ainsi, il n’est pas nécessaire de sauvegarder les informations de la session sur le serveur.
    En cela, cette authentification est qualifiée comme étant sans état (en anglais Stateless).
Le Token Web JSON(jwt) est un objet JavaScrit qui encode et transmet les informations d'authentification.
Le controle d'accés basé sur les roles permet de controler l'accés à certaines parties de l'application en fonction des roles des
personnes.

//NOTE : Explication sur OAuth2
OAuth est un protocole d’autorisation permettant une connexion sécurisée, en utilisant des tokens d’encodage sans état pour
sécuriser les sessions des utilisateurs sur une application web. OAuth permet à l’utilisateur et au serveur qui gère la connexion,
par exemple Google, d'autoriser l’utilisation de certaines informations par l’application.
A cause des voles de données sur les bases d'informations, certaines applications déléguent leur authentifiation aux fournisseurs
d'identité commme facebook, google, ect.
Prenons l'exemple de OpenClassrom pour expliquer le processus :
-On peut permettre à un utilisateur d'openClassroom de se connecte en passant par facebook.
-Une fois que l'utilisateur s'identifie sur facebook avec son email et mot de passe.
-OAuth demande à l'utilisateur s'il accepte de fournir certains informations à OpenClassroom.
-S'il accepte, OpenClassroom va recevoir un code d'authorisation qu'il renvoie au serveur d'authorisation de facebook.
-Ensuite, le serveur d'authorisation de facebook lui renvoie un token d'accés ou clé plubic qui lui permet de se connecter
directement au seveur de Facebook(serveur des ressoures).
-Ainsi si le serveur de facebook s'assure que ce token d'accés vient réellement du serveur d'autorisation de facebook alors la connexion
est vaidée. En fait le serveur d'API de Facebook(serveur des ressources) vérifie les informations du token d'accés.
Bien vrai que OAuth nous a permis de nous authentifié mais la liste des authorisations d'accés aux information est trés
limité. Pour avoir à un certain nombre d'information comme email ou numéro de téléphone, on utilise OIDC(Open ID Connect).
OIDC est une extension de OAuth. Ce système va faire une requete supplémentaire sur le serveur d'authorisation de facebook pour obtenir un
token d'indenté qui va contenir les information souhaité. IdP(Identity Provider) est un acronyme qui signifie fournisseur d'identité.
N.B. : Le token d'accés détient les information d'autorisation de facebook. Le token d'accés contient duex éléments : le principale
  contenant les information de l'utilisateur et un objet authorities contenant les informations permises pour le site Web client
  (OpenClassroom).
OAuth 2.0 permet l'autorisation(entrer dans le site) et OIDC permet l'authentification qui vous etes.

//NOTE: Vu sur les tests de notre applications
Lorsqu'on fait des tests sur notre application, deux types de bugs peuvent etre identifiés :
-Evident: on construit l'application mais ça ne compile pas. Ceux-ci peut etre du par une mauvaise syntaxe, ou une méthode manquante
 quelque part, ect.
-Insidieux: l'application construite compile correctement mais donne pas le résultat attendu.
Pour résoudre ces bugs, on utilise "Subcutaneous testing" en anglais, qui permet de tester de bout à bout une fonctionnalité spécifiqueou
un méthode, au lieu de tester l'application en intégralité. Le dossier "src/test/java" est le dossier qui contient les classes test.

//NOTE: Personnaisation de page d'erreur avec Spring Security
La perfonnalisation des erreurs avec Spring Security est un moyen de sécurité de notre application pour ne pas donner trop d'information
à un hacker à partir du message d'erreur. Au lieu, de laisser le système l'envoyer un message précis pour lui indiquer le problème,
on peut l'intercepter et changer le message. Par cela, on crée un dossier "error" sur le dossier "src/ressources/static" et créé des
pages HTML pour chaque cas d'erreur.
N.B. : Le mécanisme de gestion d’exceptions de Spring Security utilise des codes d’erreur spécifiques, dont les hackers peuvent se servir
pour viser certaines librairies utilisées ! Plus les hackers auront du mal à construire leur attaque à l'encontre de votre application web,
plus ils se décourageront et chercheront une application moins sécurisée.
Spring Security cherche d'abord les pages d'erreurs personnaliés par le code d'erreur avant d'appeller sa page par défaut.

//NOTE: Sécuriser une API avec JWT
Une API Rest est à caractère sans état(stateless); ce qui veut dire d'une requete à l'autre, on ne conserve pas d'état, autrement dit pas
d'information sur le serveur. Vu le contexte, l'authentiation par session est à éviter, donc on adapte l'authentification par jeton(token
authentification). refresh token = jeton d'actuaisation.

